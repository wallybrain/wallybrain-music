---
phase: 02-processing-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - package.json
  - src/lib/server/db/schema.ts
  - drizzle/
  - src/lib/server/validators/magicBytes.ts
  - src/lib/server/validators/ffprobe.ts
  - src/lib/server/processors/transcode.ts
  - src/lib/server/processors/peaks.ts
  - src/lib/server/processors/metadata.ts
  - src/lib/server/processors/artwork.ts
autonomous: true

must_haves:
  truths:
    - "ffmpeg and audiowaveform binaries are available in the Docker runtime image"
    - "An audio buffer can be validated against supported MIME types via magic bytes"
    - "An audio file can be transcoded to MP3 320kbps CBR"
    - "An audio file can produce a peaks JSON file compatible with audiowaveform v2 format"
    - "Metadata (title, artist, album, duration, bitrate) can be extracted from an audio file"
    - "Embedded cover art can be extracted and resized to 500x500 JPEG"
    - "Invalid or corrupt audio files are detected by ffprobe and rejected with clear error messages"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build with ffmpeg, audiowaveform, sharp native deps"
      contains: "static-ffmpeg"
    - path: "src/lib/server/validators/magicBytes.ts"
      provides: "Magic byte audio validation"
      exports: ["validateAudioFile"]
    - path: "src/lib/server/validators/ffprobe.ts"
      provides: "Deep audio validation via ffprobe"
      exports: ["validateWithFFprobe"]
    - path: "src/lib/server/processors/transcode.ts"
      provides: "MP3 320k CBR transcoding"
      exports: ["transcodeAudio"]
    - path: "src/lib/server/processors/peaks.ts"
      provides: "Peaks JSON generation"
      exports: ["generatePeaks"]
    - path: "src/lib/server/processors/metadata.ts"
      provides: "Audio metadata extraction"
      exports: ["extractMetadata"]
    - path: "src/lib/server/processors/artwork.ts"
      provides: "Cover art extraction and resize"
      exports: ["extractAndResizeArt"]
  key_links:
    - from: "src/lib/server/processors/transcode.ts"
      to: "ffmpeg binary"
      via: "child_process.spawn"
      pattern: "spawn\\('ffmpeg'"
    - from: "src/lib/server/processors/peaks.ts"
      to: "audiowaveform binary"
      via: "child_process.spawn"
      pattern: "spawn\\('audiowaveform'"
    - from: "src/lib/server/processors/metadata.ts"
      to: "music-metadata"
      via: "parseFile import"
      pattern: "import.*music-metadata"
    - from: "src/lib/server/processors/artwork.ts"
      to: "sharp"
      via: "sharp import"
      pattern: "import sharp"
---

<objective>
Install processing infrastructure (ffmpeg, audiowaveform, npm packages) into the Docker build, update the database schema with fields needed for processing, and create all processing functions as independent, testable modules.

Purpose: These are the building blocks that Plan 02-02 will wire together. Each processor is a pure function (filepath in, result out) with no orchestration logic.
Output: Dockerfile with binary tools, 6 new server-only modules (2 validators, 4 processors), updated schema with migration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-processing-pipeline/02-RESEARCH.md
@Dockerfile
@docker-compose.yml
@package.json
@src/lib/server/db/schema.ts
@src/lib/server/db/client.ts
@drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker build with ffmpeg, audiowaveform, and npm packages</name>
  <files>
    Dockerfile
    package.json
    src/lib/server/db/schema.ts
  </files>
  <action>
**Dockerfile changes (multi-stage build):**

Update the existing Dockerfile to add ffmpeg and audiowaveform to the runtime image. The build stage stays mostly the same.

1. Add a new first stage that copies static ffmpeg/ffprobe binaries:
   ```
   FROM mwader/static-ffmpeg:8.0.1 AS ffmpeg
   ```
   This image contains `/ffmpeg` and `/ffprobe` as static binaries.

2. In the runtime stage (the second `FROM node:20-bookworm-slim`), add BEFORE the COPY lines from builder:
   - Copy ffmpeg and ffprobe from the ffmpeg stage:
     ```
     COPY --from=ffmpeg /ffmpeg /usr/local/bin/ffmpeg
     COPY --from=ffmpeg /ffprobe /usr/local/bin/ffprobe
     ```
   - Install audiowaveform from the Debian .deb package on GitHub releases. Use `apt-get update && apt-get install -y --no-install-recommends curl libsndfile1 libgd3 libboost-program-options1.74.0 libboost-regex1.74.0 libboost-filesystem1.74.0 libmad0 libid3tag0` for runtime deps, then `curl -fsSL -o /tmp/audiowaveform.deb https://github.com/bbc/audiowaveform/releases/download/1.10.1/audiowaveform_1.10.1-1-12_amd64.deb && dpkg -i /tmp/audiowaveform.deb && rm /tmp/audiowaveform.deb && apt-get clean && rm -rf /var/lib/apt/lists/*`.
     NOTE: The bookworm (Debian 12) .deb filename pattern is `audiowaveform_1.10.1-1-12_amd64.deb`. Check the actual release assets at https://github.com/bbc/audiowaveform/releases/tag/1.10.1 and use the correct filename for bookworm/amd64. If the exact filename differs, use the one matching Debian 12 (bookworm) amd64.

3. In the builder stage, keep `npm ci` which will now also install sharp's native deps (sharp downloads prebuilt binaries automatically on npm install).

**npm packages:**

Run `npm install music-metadata sharp file-type` to add to package.json dependencies. These are the three new runtime dependencies.

Note: `file-type` is ESM-only (v17+), which is fine because package.json has `"type": "module"`.

**Schema update:**

Add two new columns to the `tracks` table in `src/lib/server/db/schema.ts`:
- `originalFilename: text('original_filename')` -- stores the name of the uploaded file
- `errorMessage: text('error_message')` -- stores the error message if processing fails

Keep `audioPath` as `.notNull()` -- at upload time, set it to the path of the saved original file. The transcoded MP3 path will be stored here after processing replaces it (or use a separate field if cleaner -- use your judgment, but do NOT break the existing notNull constraint).

After updating the schema, run `npx drizzle-kit generate` to create the migration SQL file. Verify the migration looks correct.

Do NOT change `title` from `.notNull()` -- at upload time, derive a default title from the original filename (strip extension). The upload endpoint (Plan 02-02) will handle this.
  </action>
  <verify>
    Run `docker build --target builder -t wm-test .` from `/home/user/wallybrain-music/` to verify the builder stage completes (npm packages install, build succeeds).

    Then run `docker build -t wm-test-full .` to verify the full build completes, including ffmpeg/audiowaveform installation.

    Then run `docker run --rm wm-test-full ffmpeg -version` and `docker run --rm wm-test-full audiowaveform --version` to verify both binaries are available in the runtime image.

    Run `npx drizzle-kit generate` and verify a new migration SQL file appears in `drizzle/`.
  </verify>
  <done>
    Docker image builds successfully with ffmpeg, ffprobe, and audiowaveform available as executables in the runtime stage. package.json includes music-metadata, sharp, and file-type as dependencies. Schema has originalFilename and errorMessage columns. New Drizzle migration file exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Processing functions and validators</name>
  <files>
    src/lib/server/validators/magicBytes.ts
    src/lib/server/validators/ffprobe.ts
    src/lib/server/processors/transcode.ts
    src/lib/server/processors/peaks.ts
    src/lib/server/processors/metadata.ts
    src/lib/server/processors/artwork.ts
  </files>
  <action>
Create 6 server-only modules under `src/lib/server/`. Each is an independent function with no cross-dependencies (they do not import each other). All child process calls use `spawn` from `node:child_process`, NEVER `exec` (prevents shell injection).

**src/lib/server/validators/magicBytes.ts:**
- Export `validateAudioFile(buffer: Buffer): Promise<{ valid: boolean; mime?: string; error?: string }>`
- Import `fileTypeFromBuffer` from `file-type`
- Supported MIME types: `audio/mpeg`, `audio/flac`, `audio/wav`, `audio/ogg`, `audio/aac`, `audio/x-wav`
- Pass the buffer directly to `fileTypeFromBuffer` (it only needs the first ~4100 bytes but handles full buffers fine)
- Return `{ valid: false, error: 'Unknown file type' }` if fileTypeFromBuffer returns null/undefined
- Return `{ valid: false, error: 'Unsupported audio format: <mime>' }` if MIME not in supported list
- Return `{ valid: true, mime: type.mime }` on success

**src/lib/server/validators/ffprobe.ts:**
- Export `validateWithFFprobe(filepath: string): Promise<{ valid: boolean; duration?: number; bitrate?: number; error?: string }>`
- Use `spawn('ffprobe', ['-v', 'error', '-show_entries', 'format=duration,bit_rate', '-of', 'json', filepath])`
- Collect stdout and stderr via data events
- On close with code 0: parse JSON, extract `format.duration` (parseFloat) and `format.bit_rate` (parseInt)
- On close with non-zero code: return `{ valid: false, error: 'Corrupt or invalid audio file' }`
- Wrap in try/catch for JSON parse errors

**src/lib/server/processors/transcode.ts:**
- Export `transcodeAudio(inputPath: string, outputPath: string): Promise<void>`
- Use `spawn('ffmpeg', ['-i', inputPath, '-codec:a', 'libmp3lame', '-b:a', '320k', '-write_id3v2', '1', '-id3v2_version', '3', '-map_metadata', '0', '-y', outputPath])`
- Collect stderr for error messages (ffmpeg writes progress to stderr, this is normal)
- Resolve on close code 0, reject with Error containing stderr on non-zero

**src/lib/server/processors/peaks.ts:**
- Export `generatePeaks(audioPath: string, outputPath: string): Promise<void>`
- Use `spawn('audiowaveform', ['-i', audioPath, '-o', outputPath, '--pixels-per-second', '20', '--bits', '8'])`
- Same pattern: collect stderr, resolve/reject on close code

**src/lib/server/processors/metadata.ts:**
- Export `extractMetadata(filepath: string): Promise<{ title?: string; artist?: string; album?: string; coverArt: Buffer | null }>`
- Import `{ parseFile, selectCover }` from `music-metadata`
- Call `parseFile(filepath)`
- IMPORTANT: `metadata.common.picture` is an ARRAY, not a single value. Use `selectCover(metadata.common.picture)` to get the primary cover image
- Return coverArt as `cover.data` (Buffer) or null if no picture array or selectCover returns null
- Return title, artist, album from `metadata.common.*` (all optional/undefined)

**src/lib/server/processors/artwork.ts:**
- Export `extractAndResizeArt(coverBuffer: Buffer, outputPath: string): Promise<void>`
- Import `sharp` (default import)
- Call `sharp(coverBuffer).resize(500, 500, { fit: 'cover' }).jpeg({ quality: 85 }).toFile(outputPath)`
- Wrap in try/catch -- if sharp fails (corrupt image), log the error and re-throw with message "Cover art processing failed: <original message>". The caller (processTrack in Plan 02-02) will decide whether to treat artwork failure as fatal or skip it.

All files must be under `src/lib/server/` to ensure SvelteKit treats them as server-only (never bundled to client).
  </action>
  <verify>
    Run `npm run check` (svelte-check) from `/home/user/wallybrain-music/` to verify TypeScript compilation passes for all new files.

    Verify all 6 files exist:
    - `ls src/lib/server/validators/magicBytes.ts`
    - `ls src/lib/server/validators/ffprobe.ts`
    - `ls src/lib/server/processors/transcode.ts`
    - `ls src/lib/server/processors/peaks.ts`
    - `ls src/lib/server/processors/metadata.ts`
    - `ls src/lib/server/processors/artwork.ts`

    Verify each file exports the expected function name (grep for the export).
  </verify>
  <done>
    Six server-only modules exist, each exporting a single function: validateAudioFile, validateWithFFprobe, transcodeAudio, generatePeaks, extractMetadata, extractAndResizeArt. All child process calls use spawn() with argument arrays. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. Docker image builds with ffmpeg, ffprobe, and audiowaveform available
2. npm packages music-metadata, sharp, file-type are in package.json
3. Schema includes originalFilename and errorMessage columns with Drizzle migration
4. All 6 processing/validation modules exist and export correct functions
5. No module uses exec() -- all use spawn() with argument arrays
6. TypeScript compiles cleanly
</verification>

<success_criteria>
The Docker image contains all binary tools needed for audio processing. Six independent processing functions are ready to be composed by the orchestrator in Plan 02-02. The database schema supports tracking original filenames and error messages during processing.
</success_criteria>

<output>
After completion, create `.planning/phases/02-processing-pipeline/02-01-SUMMARY.md`
</output>
