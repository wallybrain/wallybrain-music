---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - wallybrain-music/package.json
  - wallybrain-music/svelte.config.js
  - wallybrain-music/vite.config.ts
  - wallybrain-music/tsconfig.json
  - wallybrain-music/src/lib/server/db/schema.ts
  - wallybrain-music/src/lib/server/db/client.ts
  - wallybrain-music/src/lib/server/db/migrate.ts
  - wallybrain-music/drizzle.config.ts
  - wallybrain-music/src/routes/+layout.svelte
  - wallybrain-music/src/routes/+page.svelte
  - wallybrain-music/src/routes/+page.server.ts
  - wallybrain-music/src/routes/health/+server.ts
  - wallybrain-music/src/app.css
  - wallybrain-music/src/app.html
  - wallybrain-music/Dockerfile
  - wallybrain-music/docker-compose.yml
  - wallybrain-music/.env
  - wallybrain-music/.gitignore
autonomous: true

must_haves:
  truths:
    - "SvelteKit application starts and serves a page at /music base path"
    - "SQLite database exists with tracks, tags, and track_tags tables"
    - "Health endpoint responds with 200 when database is accessible"
    - "Docker container builds, starts, and reports healthy"
    - "Filesystem storage directories (audio, peaks, art, db) exist and are writable"
  artifacts:
    - path: "src/lib/server/db/schema.ts"
      provides: "Drizzle schema for tracks, tags, track_tags tables"
      contains: "sqliteTable"
    - path: "src/lib/server/db/client.ts"
      provides: "Drizzle + better-sqlite3 database connection"
      contains: "drizzle"
    - path: "src/routes/health/+server.ts"
      provides: "Docker health check endpoint"
      exports: ["GET"]
    - path: "svelte.config.js"
      provides: "SvelteKit config with adapter-node and base path"
      contains: "base: '/music'"
    - path: "Dockerfile"
      provides: "Multi-stage Docker build for SvelteKit"
      contains: "HEALTHCHECK"
    - path: "docker-compose.yml"
      provides: "Container orchestration with volumes"
      contains: "wallybrain-music"
  key_links:
    - from: "src/routes/health/+server.ts"
      to: "src/lib/server/db/client.ts"
      via: "import db, execute SELECT 1"
      pattern: "import.*db.*from.*client"
    - from: "src/routes/+page.server.ts"
      to: "src/lib/server/db/client.ts"
      via: "import db, query tracks"
      pattern: "import.*db.*from.*client"
    - from: "Dockerfile"
      to: "docker-compose.yml"
      via: "build context and volume mounts"
      pattern: "build.*\\."
    - from: "docker-compose.yml"
      to: "src/routes/health/+server.ts"
      via: "HEALTHCHECK hitting /music/health"
      pattern: "healthcheck"
---

<objective>
Scaffold the SvelteKit application with Drizzle ORM, SQLite database schema, Tailwind CSS, Docker container, and health endpoint.

Purpose: Create the complete application foundation that all subsequent phases build on -- the running, healthy container with a working database.
Output: A Docker container running SvelteKit at port 8800 with SQLite database, health endpoint, and filesystem storage directories.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold SvelteKit project with database schema and health endpoint</name>
  <files>
    package.json
    svelte.config.js
    vite.config.ts
    tsconfig.json
    src/lib/server/db/schema.ts
    src/lib/server/db/client.ts
    src/lib/server/db/migrate.ts
    drizzle.config.ts
    src/routes/+layout.svelte
    src/routes/+page.svelte
    src/routes/+page.server.ts
    src/routes/health/+server.ts
    src/app.css
    src/app.html
    .gitignore
    .env
  </files>
  <action>
    Create the SvelteKit project in /home/user/wallybrain-music/ (the project root -- files go directly here, NOT in a subdirectory).

    **Step 1: Scaffold with sv CLI**
    Run `npx sv create . --template minimal --types ts` in /home/user/wallybrain-music/ to scaffold the project in-place. If the CLI prompts interactively, use flags to avoid prompts or manually create the scaffold files.

    If `sv create` does not work non-interactively, manually scaffold by:
    - Initialize package.json with `npm init -y`
    - Install core deps: `npm install @sveltejs/kit svelte @sveltejs/adapter-node vite`
    - Install database deps: `npm install drizzle-orm better-sqlite3`
    - Install dev deps: `npm install -D drizzle-kit @tailwindcss/vite tailwindcss @types/better-sqlite3 typescript svelte-check`
    - Create all config files manually following the research patterns

    **Step 2: Configure SvelteKit**
    svelte.config.js -- use adapter-node with `out: 'build'` and `precompress: true`. Set `paths.base: '/music'`. This is critical: the app lives at wallyblanchard.com/music.

    vite.config.ts -- include `@tailwindcss/vite` plugin BEFORE `sveltekit()` plugin (order matters for Tailwind v4).

    **Step 3: Create database layer**
    src/lib/server/db/schema.ts -- Define three tables using Drizzle ORM:
    - `tracks`: id (text PK), slug (text unique), title (text), description (text nullable), duration (integer nullable), bitrate (integer nullable), fileSize (integer nullable), audioPath (text), peaksPath (text nullable), artPath (text nullable), artThumb (text nullable), category (text enum: track/set/experiment/export, default 'track'), status (text enum: pending/processing/ready/failed, default 'pending'), playCount (integer default 0), createdAt (text, default sql`(current_timestamp)`), updatedAt (text, default sql`(current_timestamp)`)
    - `tags`: id (integer PK autoincrement), name (text unique)
    - `trackTags`: trackId (text FK -> tracks.id cascade), tagId (integer FK -> tags.id cascade), composite PK on both columns

    Use EXACTLY the schema from the research -- do not use JavaScript Date defaults, use sql`(current_timestamp)`.

    src/lib/server/db/client.ts -- Create better-sqlite3 connection at path from DATABASE_URL env var (fallback './data/db/music.db'). Enable WAL mode and foreign keys via pragmas. Export drizzle instance with schema.

    src/lib/server/db/migrate.ts -- Import migrate from drizzle-orm/better-sqlite3/migrator. Run migrations from './drizzle' folder. Log success.

    drizzle.config.ts -- Point to schema at './src/lib/server/db/schema.ts', dialect 'sqlite', dbCredentials url from DATABASE_URL env or './data/db/music.db', output to './drizzle'.

    **Step 4: Generate initial migration**
    Run `npx drizzle-kit generate` to create the initial migration SQL files in ./drizzle/.

    **Step 5: Create routes**
    src/routes/+layout.svelte -- Import '../app.css', use Svelte 5 runes: `let { children } = $props()` and `{@render children()}`.

    src/app.css -- Just `@import "tailwindcss";` (Tailwind v4 syntax, NOT v3 directives).

    src/routes/+page.svelte -- Minimal dark-themed landing page:
    ```svelte
    <script>
      let { data } = $props();
    </script>
    <div class="min-h-screen bg-gray-950 flex items-center justify-center">
      <div class="text-center">
        <h1 class="text-4xl font-bold text-white tracking-tight">wallybrain</h1>
        <p class="mt-2 text-gray-500">music platform</p>
        <p class="mt-4 text-gray-600 text-sm">{data.trackCount} tracks</p>
      </div>
    </div>
    ```

    src/routes/+page.server.ts -- Server load function that queries the count of tracks with status 'ready' from the database. Return `{ trackCount }`. This proves the database connection works from a route.

    src/routes/health/+server.ts -- GET handler that runs `db.run(sql\`SELECT 1\`)` inside a try/catch. Return 200 'OK' on success, 503 'Database unreachable' on failure. Import db from '$lib/server/db/client' and sql from 'drizzle-orm'.

    **Step 6: Create .gitignore**
    Include: node_modules, build, .svelte-kit, .env, data/, *.db, .DS_Store

    **Step 7: Create .env**
    ```
    DATABASE_URL=./data/db/music.db
    ```

    **Step 8: Verify locally**
    Create ./data/db/ directory. Run `npx drizzle-kit push` to create the local database. Run `npm run dev` briefly to verify the app starts and the health endpoint responds.
  </action>
  <verify>
    1. `npm run build` completes without errors
    2. `ls drizzle/*.sql` shows migration file(s)
    3. `npx drizzle-kit push` creates the SQLite database at ./data/db/music.db
    4. `npm run dev -- --port 8800` starts the server (run briefly, then kill)
    5. `curl http://localhost:8800/music/health` returns 200 OK (while dev server is running)
    6. `curl http://localhost:8800/music/` returns HTML containing "wallybrain" (while dev server is running)
  </verify>
  <done>
    SvelteKit project scaffolded with TypeScript, Tailwind v4, Drizzle ORM, SQLite schema (tracks/tags/track_tags), health endpoint, and landing page. Local dev server builds and serves at /music base path. Database connection confirmed via health endpoint and page server load.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker container with multi-stage build and volume mounts</name>
  <files>
    Dockerfile
    docker-compose.yml
  </files>
  <action>
    **Step 1: Create Dockerfile**
    Multi-stage build following the research pattern:

    Build stage (node:20-bookworm-slim AS builder):
    - WORKDIR /app
    - Copy package*.json, run npm ci
    - Copy all source, run npm run build
    - Run npm prune --production

    Runtime stage (node:20-bookworm-slim):
    - WORKDIR /app
    - Create data directories: mkdir -p /data/audio /data/peaks /data/art /data/db
    - Copy from builder: build/, node_modules/, package.json, drizzle/
    - EXPOSE 8800
    - Set ENV vars: NODE_ENV=production, PORT=8800, ORIGIN=https://wallyblanchard.com, BODY_SIZE_LIMIT=512M, DATABASE_URL=/data/db/music.db
    - HEALTHCHECK: wget --no-verbose --tries=1 --spider http://localhost:8800/music/health (interval 30s, timeout 5s, retries 3)
    - CMD ["node", "build"]

    Important: The HEALTHCHECK URL must be http://localhost:8800/music/health (with /music prefix) because SvelteKit's adapter-node server expects the base path even when accessed directly (not through Caddy).

    **Step 2: Create docker-compose.yml**
    Service `wallybrain-music`:
    - build: . (build from local Dockerfile)
    - container_name: wallybrain-music
    - restart: unless-stopped
    - volumes: bind mount /home/user/wallybrain-music/data:/data (bind mount, not named volume -- simpler for backup per research)
    - environment: PORT=8800, ORIGIN=https://wallyblanchard.com, BODY_SIZE_LIMIT=512M, DATABASE_URL=/data/db/music.db
    - healthcheck: same as Dockerfile (test, interval, timeout, retries)
    - DO NOT add network config yet -- that happens in Plan 02 when we create the shared network

    **Step 3: Create persistent data directory**
    Create /home/user/wallybrain-music/data/db/, data/audio/, data/peaks/, data/art/ directories on the host. These will be bind-mounted into the container.

    **Step 4: Build and run**
    Run `docker compose build` then `docker compose up -d` in /home/user/wallybrain-music/.

    **Step 5: Verify container health**
    Wait for container to start (up to 60s). Check `docker compose ps` shows healthy status. Check `docker logs wallybrain-music` for any errors. Test health endpoint from host: `curl http://localhost:8800/music/health`.

    **Step 6: Verify database on volume**
    Confirm /home/user/wallybrain-music/data/db/music.db exists on the host filesystem (proving the bind mount works).

    Note: The database needs to be initialized inside the container. Add a startup script or ensure drizzle migrations run on container start. The simplest approach: modify the CMD or add an entrypoint that runs `node -e "require('./drizzle/migrate')"` before starting the server. Alternatively, since drizzle-kit push was already run locally and the data/ directory is bind-mounted, the database from Task 1's local verification will already be present.

    Actually, the cleanest approach: ensure the migrate.ts logic runs on application startup. In src/lib/server/db/client.ts, after creating the drizzle instance, import and run the migration inline (or create a separate init function called from hooks.server.ts). The simplest for Phase 1: use a SvelteKit server hook (src/hooks.server.ts) that runs migrations on first request or app startup.

    Create src/hooks.server.ts:
    ```typescript
    import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
    import { db } from '$lib/server/db/client';

    // Run migrations on startup
    migrate(db, { migrationsFolder: './drizzle' });
    ```

    This ensures the database is always up-to-date when the container starts, regardless of whether the bind mount already has a database file.

    Update Dockerfile to also COPY drizzle/ folder (already included above).
  </action>
  <verify>
    1. `docker compose build` completes without errors
    2. `docker compose up -d` starts the container
    3. `docker compose ps` shows wallybrain-music as healthy (wait up to 90s)
    4. `curl http://localhost:8800/music/health` returns 200 OK
    5. `curl http://localhost:8800/music/` returns HTML containing "wallybrain"
    6. `ls /home/user/wallybrain-music/data/db/music.db` confirms database file exists on host
    7. `ls /home/user/wallybrain-music/data/audio /home/user/wallybrain-music/data/peaks /home/user/wallybrain-music/data/art` confirms storage directories exist
  </verify>
  <done>
    Docker container builds via multi-stage Dockerfile, starts with docker-compose, passes health checks (hitting /music/health which verifies database connectivity), serves the SvelteKit landing page, and persists data via bind-mounted volume at /home/user/wallybrain-music/data/. Storage directories for audio, peaks, art, and db all exist and are writable.
  </done>
</task>

</tasks>

<verification>
1. `docker compose ps` in /home/user/wallybrain-music/ shows container as "healthy"
2. `curl http://localhost:8800/music/health` returns "OK" with status 200
3. `curl http://localhost:8800/music/` returns HTML page with "wallybrain" heading
4. SQLite database exists at /home/user/wallybrain-music/data/db/music.db
5. Storage directories exist: data/audio/, data/peaks/, data/art/
6. `docker restart wallybrain-music && sleep 10 && curl http://localhost:8800/music/health` returns OK (survives restart)
</verification>

<success_criteria>
- SvelteKit application builds and runs inside Docker container on port 8800
- Health endpoint at /music/health confirms database connectivity
- Landing page at /music/ renders with "wallybrain" branding
- SQLite database has tracks, tags, and track_tags tables
- Filesystem storage directories (audio, peaks, art) exist inside /data volume
- Container restarts automatically (restart: unless-stopped) and reports healthy
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
