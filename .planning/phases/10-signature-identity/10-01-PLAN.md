---
phase: 10-signature-identity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/server/db/schema.ts
  - src/lib/server/processors/artwork.ts
  - src/lib/server/processors/processTrack.ts
  - src/lib/utils/colorUtils.ts
  - src/lib/components/EqIndicator.svelte
  - src/app.css
autonomous: true

must_haves:
  truths:
    - "Every track with cover art has a dominantColor hex string stored in the database"
    - "Newly uploaded tracks automatically extract and store dominantColor during processing"
    - "Existing tracks with art have been backfilled with dominantColor values"
    - "An RGB-to-OKLCH utility function converts hex colors to OKLCH notation"
    - "An EqIndicator component renders animated equalizer bars via pure CSS"
  artifacts:
    - path: "src/lib/server/db/schema.ts"
      provides: "dominantColor column on tracks table"
      contains: "dominantColor"
    - path: "src/lib/server/processors/artwork.ts"
      provides: "extractDominantColor function using sharp stats()"
      contains: "extractDominantColor"
    - path: "src/lib/server/processors/processTrack.ts"
      provides: "Integration of extractDominantColor into processing pipeline"
      contains: "dominantColor"
    - path: "src/lib/utils/colorUtils.ts"
      provides: "rgbHexToOklch and formatOklch utility functions"
      contains: "rgbHexToOklch"
    - path: "src/lib/components/EqIndicator.svelte"
      provides: "Pure CSS animated equalizer bar component"
      contains: "eq-bar"
    - path: "src/app.css"
      provides: "Equalizer keyframe animations and animation tokens"
      contains: "@keyframes eq1"
  key_links:
    - from: "src/lib/server/processors/processTrack.ts"
      to: "src/lib/server/processors/artwork.ts"
      via: "import extractDominantColor"
      pattern: "import.*extractDominantColor.*artwork"
    - from: "src/lib/server/processors/processTrack.ts"
      to: "src/lib/server/db/schema.ts"
      via: "stores dominantColor in tracks table"
      pattern: "dominantColor"
    - from: "src/app.css"
      to: "src/lib/components/EqIndicator.svelte"
      via: "animation utility classes (animate-eq1, eq2, eq3)"
      pattern: "--animate-eq"
---

<objective>
Add dominant color extraction to the track processing pipeline, create the color utility module, build the EqIndicator component, and backfill existing tracks.

Purpose: Provides the data foundation (dominantColor in DB) and reusable components (colorUtils, EqIndicator) that Plan 02 needs to apply visual effects on the frontend.
Output: Schema with dominantColor, extraction in pipeline, all existing tracks backfilled, colorUtils module, EqIndicator component, equalizer CSS keyframes.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-signature-identity/10-RESEARCH.md
@src/lib/server/db/schema.ts
@src/lib/server/processors/artwork.ts
@src/lib/server/processors/processTrack.ts
@src/app.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema, color extraction, pipeline integration, and backfill</name>
  <files>src/lib/server/db/schema.ts, src/lib/server/processors/artwork.ts, src/lib/server/processors/processTrack.ts</files>
  <action>
1. **Schema change** (`src/lib/server/db/schema.ts`):
   Add `dominantColor` column to the tracks table, after `artPath`:
   ```typescript
   dominantColor: text('dominant_color'),
   ```
   This is a nullable text field. No default needed.

2. **Push schema** to apply the new column:
   ```bash
   cd /home/lwb3/wallybrain-music && npx drizzle-kit push
   ```
   This is a SQLite database -- drizzle-kit push handles ALTER TABLE.

3. **Add extractDominantColor** to `src/lib/server/processors/artwork.ts`:
   Add this exported function after the existing `extractAndResizeArt`:
   ```typescript
   export async function extractDominantColor(imagePath: string): Promise<string> {
     const { dominant } = await sharp(imagePath).stats();
     const { r, g, b } = dominant;
     const hex = (n: number) => n.toString(16).padStart(2, '0');
     return `#${hex(r)}${hex(g)}${hex(b)}`;
   }
   ```
   This uses the already-installed sharp library. The `stats()` method returns the dominant color from a 4096-bin histogram as `{ r, g, b }` integers (0-255).

4. **Integrate into processTrack.ts** (`src/lib/server/processors/processTrack.ts`):
   - Import `extractDominantColor` alongside the existing `extractAndResizeArt` import from `./artwork`
   - After the cover art extraction succeeds (inside the `if (metadata.coverArt)` block, after `artSucceeded = true`), extract the dominant color:
     ```typescript
     let dominantColor: string | null = null;
     // ... inside the if (metadata.coverArt) try block, after artSucceeded = true:
     dominantColor = await extractDominantColor(artPath);
     ```
   - Declare `dominantColor` as `let dominantColor: string | null = null;` before the `if (metadata.coverArt)` block.
   - Add `dominantColor` to the db.update set object:
     ```typescript
     ...(dominantColor ? { dominantColor } : {}),
     ```
   - Place this alongside the existing `...(artSucceeded ? { artPath } : {})` line.

5. **Backfill existing tracks**: Run a one-time script to populate dominantColor for all tracks that already have cover art. Create and run this as an inline script:
   ```bash
   cd /home/lwb3/wallybrain-music && node -e "
   const { db } = require('./src/lib/server/db/client');
   const { tracks } = require('./src/lib/server/db/schema');
   const { isNotNull, eq } = require('drizzle-orm');
   const sharp = require('sharp');

   async function backfill() {
     const rows = db.select({ id: tracks.id, artPath: tracks.artPath }).from(tracks).where(isNotNull(tracks.artPath)).all();
     for (const row of rows) {
       if (!row.artPath) continue;
       try {
         const { dominant } = await sharp(row.artPath).stats();
         const hex = (n) => n.toString(16).padStart(2, '0');
         const color = '#' + hex(dominant.r) + hex(dominant.g) + hex(dominant.b);
         db.update(tracks).set({ dominantColor: color }).where(eq(tracks.id, row.id)).run();
         console.log('Track ' + row.id + ': ' + color);
       } catch (e) {
         console.error('Failed for ' + row.id + ':', e.message);
       }
     }
   }
   backfill();
   "
   ```
   NOTE: If CJS require doesn't work (SvelteKit uses ESM), use `tsx` or write a temporary `.ts` file and run with `npx tsx`. The key point is: iterate all tracks with artPath, run `sharp(artPath).stats()`, update the dominantColor column. Delete any temporary script file after running.
  </action>
  <verify>
    1. `npx drizzle-kit push` completes without error (schema applied).
    2. Query the database to confirm dominantColor column exists and has values: `sqlite3 /data/music.db "SELECT id, dominant_color FROM tracks WHERE art_path IS NOT NULL LIMIT 5;"` -- should show hex color strings like `#7c3aed`.
    3. `npm run build` succeeds.
    4. `npm run check` passes TypeScript verification.
  </verify>
  <done>
    dominantColor column exists in tracks table. extractDominantColor function exported from artwork.ts. processTrack.ts calls it and stores the result. All existing tracks with cover art have dominantColor populated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Color utility module, EqIndicator component, and equalizer CSS</name>
  <files>src/lib/utils/colorUtils.ts, src/lib/components/EqIndicator.svelte, src/app.css</files>
  <action>
1. **Create `src/lib/utils/colorUtils.ts`** with RGB-to-OKLCH conversion (~30 lines, no external dependencies):

   ```typescript
   function hexToRgb(hex: string): [number, number, number] {
     const r = parseInt(hex.slice(1, 3), 16) / 255;
     const g = parseInt(hex.slice(3, 5), 16) / 255;
     const b = parseInt(hex.slice(5, 7), 16) / 255;
     return [r, g, b];
   }

   function linearize(c: number): number {
     return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
   }

   export function rgbHexToOklch(hex: string): { l: number; c: number; h: number } {
     const [r, g, b] = hexToRgb(hex).map(linearize);
     const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
     const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
     const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
     const l1 = Math.cbrt(l_);
     const m1 = Math.cbrt(m_);
     const s1 = Math.cbrt(s_);
     const L = 0.2104542553 * l1 + 0.7936177850 * m1 - 0.0040720468 * s1;
     const a = 1.9779984951 * l1 - 2.4285922050 * m1 + 0.4505937099 * s1;
     const bVal = 0.0259040371 * l1 + 0.7827717662 * m1 - 0.8086757660 * s1;
     const C = Math.sqrt(a * a + bVal * bVal);
     let H = Math.atan2(bVal, a) * (180 / Math.PI);
     if (H < 0) H += 360;
     return { l: L, c: C, h: isNaN(H) ? 0 : H };
   }

   export function formatOklch(oklch: { l: number; c: number; h: number }, alpha?: number): string {
     const { l, c, h } = oklch;
     if (alpha !== undefined && alpha < 1) {
       return `oklch(${l.toFixed(3)} ${c.toFixed(3)} ${h.toFixed(1)} / ${alpha})`;
     }
     return `oklch(${l.toFixed(3)} ${c.toFixed(3)} ${h.toFixed(1)})`;
   }
   ```

2. **Create `src/lib/components/EqIndicator.svelte`** -- pure CSS animated equalizer bars:

   ```svelte
   <div class="flex items-end gap-[2px] h-4 w-4" aria-label="Now playing">
     <span class="w-[3px] bg-accent rounded-full origin-bottom animate-eq1"></span>
     <span class="w-[3px] bg-accent rounded-full origin-bottom animate-eq2"></span>
     <span class="w-[3px] bg-accent rounded-full origin-bottom animate-eq3"></span>
   </div>
   ```

   No script block needed -- this is a pure visual indicator. The animation classes (`animate-eq1`, `animate-eq2`, `animate-eq3`) are defined via Tailwind v4 `@theme` in app.css. The `bg-accent` class uses the existing accent design token. The `origin-bottom` ensures bars scale upward from their base.

3. **Add equalizer keyframes and animation tokens to `src/app.css`**:
   After the existing `@theme { ... }` block's last entry (before the closing `}`), add:

   ```css
   /* === Equalizer Animation === */
   --animate-eq1: eq1 1.2s ease-in-out infinite;
   --animate-eq2: eq2 1.4s ease-in-out infinite;
   --animate-eq3: eq3 1.0s ease-in-out infinite;
   ```

   After the closing `}` of `@theme`, but before `@layer base`, add the keyframe definitions:

   ```css
   @keyframes eq1 {
     0%, 100% { transform: scaleY(0.3); }
     50% { transform: scaleY(1); }
   }
   @keyframes eq2 {
     0%, 100% { transform: scaleY(0.5); }
     30% { transform: scaleY(0.2); }
     70% { transform: scaleY(1); }
   }
   @keyframes eq3 {
     0%, 100% { transform: scaleY(0.6); }
     40% { transform: scaleY(0.3); }
     80% { transform: scaleY(0.8); }
   }
   ```

   Each bar has a different keyframe pattern and duration to create organic-looking movement. Using `scaleY()` (not `height`) enables GPU-accelerated animation with no layout thrashing.
  </action>
  <verify>
    1. `npm run build` succeeds.
    2. `npm run check` passes -- colorUtils.ts types are correct, EqIndicator.svelte compiles.
    3. Confirm `src/lib/utils/colorUtils.ts` exports `rgbHexToOklch` and `formatOklch`.
    4. Confirm `src/lib/components/EqIndicator.svelte` exists and contains 3 bar spans.
    5. Confirm `src/app.css` contains `@keyframes eq1`, `@keyframes eq2`, `@keyframes eq3`, and `--animate-eq` tokens.
  </verify>
  <done>
    colorUtils.ts provides rgbHexToOklch and formatOklch functions. EqIndicator.svelte renders 3 animated equalizer bars. app.css contains equalizer keyframe definitions and animation tokens. Build and type checks pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run check` passes TypeScript verification
3. Database has `dominant_color` column with hex values for tracks with art
4. `grep "extractDominantColor" src/lib/server/processors/artwork.ts` confirms function exists
5. `grep "dominantColor" src/lib/server/processors/processTrack.ts` confirms pipeline integration
6. `grep "rgbHexToOklch" src/lib/utils/colorUtils.ts` confirms utility function exists
7. `grep "@keyframes eq1" src/app.css` confirms keyframe definitions exist
</verification>

<success_criteria>
- dominantColor column exists in tracks table schema
- extractDominantColor function works via sharp stats()
- processTrack pipeline stores dominantColor for new uploads
- All existing tracks with cover art have dominantColor populated
- colorUtils.ts exports rgbHexToOklch and formatOklch
- EqIndicator.svelte renders 3 animated bars
- Equalizer keyframes and animation tokens defined in app.css
- Build and type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-signature-identity/10-01-SUMMARY.md`
</output>
