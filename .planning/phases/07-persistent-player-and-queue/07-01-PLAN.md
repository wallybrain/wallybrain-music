---
phase: 07-persistent-player-and-queue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/stores/playerState.svelte.ts
  - src/lib/components/PersistentPlayer.svelte
  - src/routes/+layout.svelte
autonomous: true

must_haves:
  truths:
    - "A persistent bottom-bar audio player appears when a track is loaded into the global state"
    - "The player shows cover art, track title, time display, play/pause, prev/next, volume, and a mini waveform"
    - "The player bar is fixed to the bottom of the viewport and remains visible across all pages"
    - "Audio plays through wavesurfer.js in the persistent player with drag-to-seek on the mini waveform"
    - "On mobile, waveform and volume are hidden; only cover art, title, and core controls are shown"
  artifacts:
    - path: "src/lib/stores/playerState.svelte.ts"
      provides: "Global reactive player/queue state using Svelte 5 $state runes"
      exports: ["playerState", "QueueTrack"]
      contains: "class PlayerState"
    - path: "src/lib/components/PersistentPlayer.svelte"
      provides: "Bottom bar player with wavesurfer.js mini waveform"
      min_lines: 80
    - path: "src/routes/+layout.svelte"
      provides: "PersistentPlayer mounted below children slot"
      contains: "PersistentPlayer"
  key_links:
    - from: "src/lib/components/PersistentPlayer.svelte"
      to: "src/lib/stores/playerState.svelte.ts"
      via: "import playerState, $effect watches currentTrack"
      pattern: "import.*playerState"
    - from: "src/lib/components/PersistentPlayer.svelte"
      to: "/music/api/tracks/[id]/peaks"
      via: "fetch peaks then wavesurfer.load()"
      pattern: "fetch.*peaks"
    - from: "src/routes/+layout.svelte"
      to: "src/lib/components/PersistentPlayer.svelte"
      via: "conditional render when currentTrack exists"
      pattern: "playerState\\.currentTrack"
---

<objective>
Create the persistent bottom-bar audio player infrastructure: a global reactive state module for player/queue state, a PersistentPlayer component with wavesurfer.js mini waveform, and layout integration so the player bar persists across SvelteKit page navigations.

Purpose: This is the architectural foundation for persistent playback. The player component lives in the root layout (outside {@render children()}) so it survives navigation. The state module enables any page/component to trigger playback.

Output: Three files -- playerState.svelte.ts (state), PersistentPlayer.svelte (UI), updated +layout.svelte (mounting point).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-persistent-player-and-queue/07-RESEARCH.md
@src/routes/+layout.svelte
@src/lib/components/WaveformPlayer.svelte
@src/lib/components/CoverArt.svelte
@src/lib/utils/formatTime.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create global player state module</name>
  <files>src/lib/stores/playerState.svelte.ts</files>
  <action>
Create `src/lib/stores/` directory and `playerState.svelte.ts` inside it.

File MUST have `.svelte.ts` extension (not `.ts`) so Svelte compiler processes $state runes.

Export a `QueueTrack` type:
```typescript
export type QueueTrack = {
  id: string;
  slug: string;
  title: string;
  duration: number;
  artPath: string | null;
};
```

Create a `PlayerState` class with `$state` rune properties:
- `currentTrack: QueueTrack | null = $state(null)`
- `queue: QueueTrack[] = $state([])`
- `queueIndex: number = $state(-1)`
- `isPlaying: boolean = $state(false)`
- `currentTime: number = $state(0)`
- `volume: number = $state(1)`

Add `$derived`-style getters (use `get` keyword):
- `get hasNext(): boolean` -- queueIndex < queue.length - 1
- `get hasPrev(): boolean` -- queueIndex > 0

Add methods:
- `play(track: QueueTrack, queue?: QueueTrack[], index?: number)` -- sets currentTrack, queue, queueIndex, isPlaying=true, currentTime=0. Defaults: queue=[track], index=0.
- `togglePlayPause()` -- flips isPlaying
- `next(): boolean` -- if hasNext, increment queueIndex, set currentTrack to queue[queueIndex], reset currentTime, isPlaying=true, return true. Otherwise set isPlaying=false, return false.
- `prev()` -- if hasPrev, decrement queueIndex, set currentTrack, reset currentTime, isPlaying=true
- `setVolume(v: number)` -- clamp to [0, 1]
- `stop()` -- reset all state to defaults

Export a singleton: `export const playerState = new PlayerState();`

This module is client-only state (no DOM APIs, no SSR issues). The data types (strings, numbers, null) are SSR-safe defaults.
  </action>
  <verify>Run `cd /home/user/wallybrain-music && npx svelte-check --tsconfig ./tsconfig.json 2>&1 | tail -20` -- no errors in playerState.svelte.ts</verify>
  <done>playerState.svelte.ts exports QueueTrack type and playerState singleton with play/pause/next/prev/stop/setVolume methods, all using $state runes</done>
</task>

<task type="auto">
  <name>Task 2: Create PersistentPlayer component and wire into layout</name>
  <files>src/lib/components/PersistentPlayer.svelte, src/routes/+layout.svelte</files>
  <action>
**PersistentPlayer.svelte:**

Create the bottom-bar player component. Structure:

Script section:
- Import `onMount` from `svelte`, `playerState` from stores, `formatTime` from utils, `CoverArt` component, `base` from `$app/paths`, `WaveSurfer` type from wavesurfer.js.
- Local state: `container` (HTMLDivElement for wavesurfer), `wavesurfer` (WaveSurfer | null), `loadedTrackId` (string, tracks which track is loaded to prevent re-loading same track).
- `onMount`: dynamically import wavesurfer.js (`await import('wavesurfer.js')`), create instance with:
  - `container`: the bound div
  - `height: 40` (compact mini waveform)
  - `waveColor: '#4a4a5a'`, `progressColor: '#8b5cf6'`, `cursorColor: 'transparent'`
  - `barWidth: 2`, `barGap: 1`, `barRadius: 1`
  - `normalize: false`, `interact: true`, `dragToSeek: true`
- Wire wavesurfer events:
  - `finish` -> `playerState.next()` (auto-advance queue)
  - `timeupdate` -> update `playerState.currentTime`
  - `play` -> `playerState.isPlaying = true`
  - `pause` -> `playerState.isPlaying = false`
- Return cleanup function that calls `ws?.destroy()`

$effect for track loading:
- Watch `playerState.currentTrack`. If track exists, wavesurfer exists, and `track.id !== loadedTrackId`:
  - Set `loadedTrackId = track.id` (before async work, acts as stale guard)
  - Fetch peaks from `${base}/api/tracks/${track.id}/peaks`
  - On success, verify `playerState.currentTrack?.id` still matches (race condition guard), then call `wavesurfer.load(audioUrl, [peaks], track.duration)`
  - Fire play count: `fetch(\`${base}/api/tracks/${track.id}/play\`, { method: 'POST' })` (fire-and-forget, matching existing pattern from Phase 6)

$effect for play/pause sync:
- Watch `playerState.isPlaying`. If wavesurfer exists:
  - If should play and wavesurfer is not playing: `wavesurfer.play()`
  - If should not play and wavesurfer is playing: `wavesurfer.pause()`

$effect for volume sync:
- Watch `playerState.volume`, call `wavesurfer?.setVolume(playerState.volume)`

Template:
- Fixed bottom bar: `fixed bottom-0 left-0 right-0 bg-zinc-900/95 backdrop-blur border-t border-zinc-800 z-50`
- Inner container: `max-w-3xl mx-auto px-4 py-2 flex items-center gap-3`
- Cover art: Small CoverArt component (size="sm" but override to w-10 h-10 via a wrapper div with those classes), wrapped in `<a>` linking to `${base}/track/${playerState.currentTrack.slug}`
- Track info: Title (truncated, text-sm text-zinc-200) and time display (text-xs text-zinc-500 font-mono tabular-nums showing currentTime / duration). Wrap in a `min-w-0 shrink-0` div. On mobile this is visible.
- Controls: prev button (disabled when !hasPrev), play/pause button, next button (disabled when !hasNext). Use simple text labels or unicode symbols: prev="<<", play/pause toggle, next=">>". Style: small rounded buttons, violet-600 for play/pause, zinc-700 for prev/next, disabled:opacity-30. These are always visible.
- Waveform container: `bind:this={container}` div with `flex-1 min-w-0`. Add `hidden md:block` to hide on mobile (research recommendation).
- Volume slider: `<input type="range">` with `w-16 accent-violet-500 shrink-0`. Add `hidden md:flex` wrapper to hide on mobile.

Make cover art 40x40 (w-10 h-10): Since CoverArt component uses size classes, add a new `xs` size or wrap the sm CoverArt in a div with `w-10 h-10 shrink-0` and overflow-hidden rounded. Simplest: just use an img tag directly for the tiny cover art in the bottom bar -- `<img src="{base}/api/tracks/{trackId}/art" class="w-10 h-10 rounded object-cover">` with a fallback div showing the music note. This avoids modifying CoverArt.svelte.

**+layout.svelte:**

Update the existing root layout:
1. Add imports: `PersistentPlayer` from `$lib/components/PersistentPlayer.svelte`, `playerState` from `$lib/stores/playerState.svelte`
2. Add dynamic bottom padding on `<main>`: when `playerState.currentTrack` is truthy, add `pb-24` class (enough space for the fixed bottom bar). Use template conditional: `class="flex-1 {playerState.currentTrack ? 'pb-24' : ''}"`
3. Add PersistentPlayer below `</main>` but inside the outer div, conditionally rendered: `{#if playerState.currentTrack}<PersistentPlayer />{/if}`

The key architecture: PersistentPlayer is OUTSIDE `{@render children()}`, so SvelteKit never destroys it during client-side navigation.
  </action>
  <verify>Run `cd /home/user/wallybrain-music && npx svelte-check --tsconfig ./tsconfig.json 2>&1 | tail -30` -- no type errors. Then `cd /home/user/wallybrain-music && npm run build 2>&1 | tail -10` -- build succeeds.</verify>
  <done>PersistentPlayer component renders a fixed bottom bar with cover art, title, time, play/pause/prev/next controls, mini waveform, and volume slider. It persists across navigations via root layout mounting. Mobile hides waveform and volume. Build passes with no errors.</done>
</task>

</tasks>

<verification>
1. `npx svelte-check` reports no errors for new files
2. `npm run build` succeeds
3. PersistentPlayer is imported and conditionally rendered in +layout.svelte
4. playerState.svelte.ts exports playerState singleton and QueueTrack type
5. Layout adds pb-24 padding when player is active
</verification>

<success_criteria>
- playerState.svelte.ts exists with $state runes, play/pause/next/prev/stop methods, QueueTrack type export
- PersistentPlayer.svelte exists with wavesurfer.js mini waveform, all controls, mobile responsiveness
- +layout.svelte renders PersistentPlayer below children, conditionally when a track is loaded
- Build passes without errors
- No new npm dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/07-persistent-player-and-queue/07-01-SUMMARY.md`
</output>
