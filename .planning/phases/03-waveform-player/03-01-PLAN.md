---
phase: 03-waveform-player
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/routes/api/tracks/[id]/peaks/+server.ts
  - src/routes/api/tracks/[id]/audio/+server.ts
autonomous: true

must_haves:
  truths:
    - "Peaks endpoint returns normalized float array from audiowaveform 8-bit JSON"
    - "Audio endpoint streams MP3 with proper HTTP 206 range request responses"
    - "Safari can play audio (bytes=0-1 probe returns 206)"
    - "Both endpoints return cache-immutable headers for UUID-based paths"
  artifacts:
    - path: "src/routes/api/tracks/[id]/peaks/+server.ts"
      provides: "Normalized peaks JSON endpoint"
      exports: ["GET"]
    - path: "src/routes/api/tracks/[id]/audio/+server.ts"
      provides: "Audio streaming with range requests"
      exports: ["GET"]
  key_links:
    - from: "src/routes/api/tracks/[id]/peaks/+server.ts"
      to: "/data/peaks/{id}.json"
      via: "readFileSync"
      pattern: "readFileSync.*peaksPath"
    - from: "src/routes/api/tracks/[id]/audio/+server.ts"
      to: "/data/audio/{id}.mp3"
      via: "createReadStream"
      pattern: "createReadStream.*filePath"
    - from: "src/routes/api/tracks/[id]/audio/+server.ts"
      to: "HTTP 206"
      via: "range header parsing"
      pattern: "status:\\s*206"
---

<objective>
Create the server-side API endpoints that serve peak data and stream audio files for the waveform player.

Purpose: The WaveformPlayer component (Plan 03-02) needs two data sources: normalized peak data for instant waveform rendering, and an audio stream with HTTP range request support for seeking and Safari compatibility.

Output: Two SvelteKit +server.ts endpoints at /api/tracks/[id]/peaks and /api/tracks/[id]/audio
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-waveform-player/03-RESEARCH.md
@src/lib/server/db/schema.ts
@svelte.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Peaks normalization endpoint</name>
  <files>src/routes/api/tracks/[id]/peaks/+server.ts</files>
  <action>
Create GET endpoint at src/routes/api/tracks/[id]/peaks/+server.ts that:

1. Imports: RequestHandler from './$types', readFileSync from 'node:fs', error and json from '@sveltejs/kit', db and tracks from the database (to look up the track's peaksPath).

2. Looks up the track by params.id in the database to get peaksPath. If track not found or peaksPath is null, throw error(404, 'Peaks not found').

3. Reads the peaks JSON file from the filesystem path stored in peaksPath (which will be like /data/peaks/{id}.json).

4. Parses the JSON. The audiowaveform output format is:
   ```json
   { "version": 2, "channels": 1, "sample_rate": ..., "samples_per_pixel": ..., "bits": 8, "length": N, "data": [int, int, ...] }
   ```
   The `data` array contains 8-bit integers ranging from -127 to 127. These are interleaved min/max pairs per sample.

5. Normalizes the data array by dividing each value by 127 to produce floats in the -1.0 to 1.0 range. This is required because wavesurfer.js expects float peaks.

6. Returns the normalized array as JSON (just the float array, not the full audiowaveform object) with these response headers:
   - Cache-Control: public, max-age=31536000, immutable

Handle errors: If the peaks file cannot be read or parsed, throw error(404, 'Peaks not found').

Note: Use the database lookup (not just the filesystem path) to validate the track exists. This prevents serving peaks for deleted tracks.
  </action>
  <verify>
After Docker rebuild and container restart:
1. `svelte-check` passes with 0 errors
2. `curl -s http://localhost:8800/music/api/tracks/{TRACK_ID}/peaks | head -c 200` returns a JSON array of float values between -1.0 and 1.0
3. `curl -sI http://localhost:8800/music/api/tracks/{TRACK_ID}/peaks` shows Cache-Control: public, max-age=31536000, immutable
4. `curl -s http://localhost:8800/music/api/tracks/nonexistent-id/peaks` returns 404

Use the track ID from the existing test upload in the database. Query it with: `docker exec wallybrain-music node -e "const db=require('better-sqlite3')('/data/db/music.db');console.log(db.prepare('SELECT id, status, peaks_path FROM tracks WHERE status=?').all('ready'))"` -- if no ready tracks exist, note this and verify the endpoint structure compiles and returns 404 for a missing track.
  </verify>
  <done>GET /music/api/tracks/[id]/peaks returns a JSON array of normalized floats (-1.0 to 1.0) with immutable cache headers, or 404 for missing tracks/peaks</done>
</task>

<task type="auto">
  <name>Task 2: Audio streaming endpoint with range requests</name>
  <files>src/routes/api/tracks/[id]/audio/+server.ts</files>
  <action>
Create GET endpoint at src/routes/api/tracks/[id]/audio/+server.ts that:

1. Imports: RequestHandler from './$types', createReadStream and statSync from 'node:fs', Readable from 'node:stream', error from '@sveltejs/kit', db and tracks from the database.

2. Looks up the track by params.id in the database to get audioPath. If track not found or status is not 'ready', throw error(404, 'Track not found').

3. Uses statSync on the audioPath to get fileSize. If the file does not exist on disk, throw error(404, 'Track not found').

4. Defines base headers shared by all responses:
   - Accept-Ranges: bytes (critical for Safari -- must be present even on non-range responses)
   - Content-Type: audio/mpeg
   - Cache-Control: public, max-age=31536000, immutable

5. Checks for the Range request header:

   **If no Range header:** Return the full file as a 200 response.
   - Create a ReadStream for the full file
   - Convert to web ReadableStream via Readable.toWeb(stream) as ReadableStream
   - Set Content-Length to fileSize
   - Return new Response with status 200

   **If Range header present:** Parse and return partial content as 206.
   - Parse "bytes=START-END" format: `range.replace(/bytes=/, '').split('-')`
   - start = parseInt(parts[0], 10)
   - end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1
   - Clamp end to fileSize - 1 if it exceeds file size
   - chunkSize = end - start + 1
   - Create a ReadStream with { start, end } options
   - Convert to web ReadableStream
   - Add Content-Range: bytes START-END/TOTAL header
   - Set Content-Length to chunkSize
   - Return new Response with status 206

Important details:
- HTTP range bytes are inclusive on both ends (start AND end are included in the response)
- Safari sends `bytes=0-1` as an initial probe -- this must return exactly 2 bytes with status 206
- The Content-Range header format is: `bytes {start}-{end}/{totalSize}`
- Use Readable.toWeb() to convert Node.js ReadStream to web ReadableStream (cast as ReadableStream for TypeScript)
  </action>
  <verify>
After Docker rebuild and container restart:
1. `svelte-check` passes with 0 errors
2. Full file request: `curl -sI http://localhost:8800/music/api/tracks/{TRACK_ID}/audio` returns 200 with Content-Type: audio/mpeg, Accept-Ranges: bytes, and Content-Length matching the MP3 file size
3. Range request: `curl -sI -H "Range: bytes=0-1" http://localhost:8800/music/api/tracks/{TRACK_ID}/audio` returns 206 with Content-Range: bytes 0-1/{filesize} and Content-Length: 2
4. Mid-file range: `curl -sI -H "Range: bytes=1000-1999" http://localhost:8800/music/api/tracks/{TRACK_ID}/audio` returns 206 with Content-Range and Content-Length: 1000
5. Open-ended range: `curl -sI -H "Range: bytes=1000-" http://localhost:8800/music/api/tracks/{TRACK_ID}/audio` returns 206 with Content-Range showing end = filesize-1
6. Missing track: `curl -s http://localhost:8800/music/api/tracks/nonexistent/audio` returns 404

Use the same track ID as Task 1.
  </verify>
  <done>GET /music/api/tracks/[id]/audio streams MP3 with Accept-Ranges: bytes on all responses, returns 206 Partial Content for range requests (including Safari bytes=0-1 probe), returns 200 with full file when no range header, returns 404 for missing tracks</done>
</task>

</tasks>

<verification>
1. Both endpoints exist and TypeScript compiles cleanly (svelte-check 0 errors)
2. Peaks endpoint normalizes 8-bit integers to floats and returns JSON array
3. Audio endpoint handles full request (200), range request (206), and Safari probe (bytes=0-1 -> 206)
4. Both endpoints return 404 for nonexistent tracks
5. Both endpoints include immutable cache headers
6. Docker container builds and starts healthy with new endpoints
</verification>

<success_criteria>
- Peaks endpoint serves normalized float peaks for any ready track
- Audio endpoint handles range requests correctly for seeking support
- Safari range probe (bytes=0-1) returns proper 206 response
- Both endpoints validate track existence via database lookup
- All responses include appropriate cache headers
</success_criteria>

<output>
After completion, create `.planning/phases/03-waveform-player/03-01-SUMMARY.md`
</output>
