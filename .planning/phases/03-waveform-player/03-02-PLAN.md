---
phase: 03-waveform-player
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - package.json
  - src/lib/utils/formatTime.ts
  - src/lib/components/WaveformPlayer.svelte
  - src/routes/+page.svelte
  - src/routes/+page.server.ts
autonomous: true

must_haves:
  truths:
    - "Visitor can click play and see the waveform animate as audio plays"
    - "Visitor can click pause and audio stops"
    - "Visitor can click or drag anywhere on the waveform to seek"
    - "Waveform renders immediately from pre-generated peaks without client-side decoding"
    - "Current time and total duration display and update in real time"
    - "Visitor can adjust volume via a slider control"
    - "Loading state is shown while wavesurfer.js initializes"
  artifacts:
    - path: "src/lib/components/WaveformPlayer.svelte"
      provides: "Reusable waveform player component"
      min_lines: 80
    - path: "src/lib/utils/formatTime.ts"
      provides: "Time formatting utility"
      exports: ["formatTime"]
    - path: "package.json"
      provides: "wavesurfer.js dependency"
      contains: "wavesurfer.js"
  key_links:
    - from: "src/lib/components/WaveformPlayer.svelte"
      to: "/api/tracks/[id]/peaks"
      via: "fetch in onMount"
      pattern: "fetch.*peaks"
    - from: "src/lib/components/WaveformPlayer.svelte"
      to: "/api/tracks/[id]/audio"
      via: "wavesurfer url option"
      pattern: "url.*audio"
    - from: "src/lib/components/WaveformPlayer.svelte"
      to: "wavesurfer.js"
      via: "dynamic import in onMount"
      pattern: "import.*wavesurfer"
    - from: "src/routes/+page.svelte"
      to: "src/lib/components/WaveformPlayer.svelte"
      via: "component import"
      pattern: "WaveformPlayer"
    - from: "src/routes/+page.server.ts"
      to: "tracks table"
      via: "database query for ready tracks"
      pattern: "tracks.*ready"
---

<objective>
Build the WaveformPlayer Svelte component with wavesurfer.js integration and wire it into the main page to play tracks with waveform visualization.

Purpose: This is the core user-facing deliverable of Phase 3 -- the interactive waveform player that makes wallybrain-music feel like a real music platform rather than a file listing.

Output: A reusable WaveformPlayer.svelte component with play/pause, seek, volume, time display, and loading states. Wired into the main /music page displaying ready tracks.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-waveform-player/03-RESEARCH.md
@.planning/phases/03-waveform-player/03-01-SUMMARY.md
@src/lib/server/db/schema.ts
@src/routes/+page.svelte
@src/routes/+page.server.ts
@svelte.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install wavesurfer.js and create WaveformPlayer component</name>
  <files>
    package.json
    src/lib/utils/formatTime.ts
    src/lib/components/WaveformPlayer.svelte
  </files>
  <action>
**Step 1: Install wavesurfer.js**

Run `npm install wavesurfer.js` inside the wallybrain-music project directory. This adds the wavesurfer.js v7.x dependency.

**Step 2: Create formatTime utility**

Create src/lib/utils/formatTime.ts:
- Export function formatTime(seconds: number): string
- Guard: if !isFinite(seconds) or seconds < 0, return '0:00'
- Calculate mins = Math.floor(seconds / 60), secs = Math.floor(seconds % 60)
- Return `${mins}:${secs.toString().padStart(2, '0')}`

**Step 3: Create WaveformPlayer.svelte component**

Create src/lib/components/WaveformPlayer.svelte as a Svelte 5 component with these props (using $props() runes):
- trackId: string (UUID, used to construct API URLs)
- duration: number (total duration in seconds, from database)

Component state (using $state() runes):
- container: HTMLDivElement (bind:this for wavesurfer container)
- wavesurfer: WaveSurfer | null = null
- isPlaying: boolean = false
- isLoading: boolean = true
- currentTime: number = 0
- volume: number = 1

Lifecycle (onMount):
1. Dynamic import: `const { default: WaveSurfer } = await import('wavesurfer.js')` -- MUST be dynamic import inside onMount to avoid SSR errors.

2. Fetch peaks: `const res = await fetch(\`/music/api/tracks/${trackId}/peaks\`); const peaksData = await res.json();` -- Note the /music base path prefix. Handle fetch failure gracefully (log error, set isLoading=false, show error state).

3. Create WaveSurfer instance:
   ```
   ws = WaveSurfer.create({
     container,
     waveColor: '#4a4a5a',
     progressColor: '#8b5cf6',
     cursorColor: '#8b5cf6',
     cursorWidth: 2,
     height: 80,
     barWidth: 2,
     barGap: 1,
     barRadius: 2,
     normalize: false,
     interact: true,
     dragToSeek: true,
     url: `/music/api/tracks/${trackId}/audio`,
     peaks: [peaksData],
     duration: duration,
   });
   ```

4. Wire events:
   - ws.on('play', () => isPlaying = true)
   - ws.on('pause', () => isPlaying = false)
   - ws.on('finish', () => isPlaying = false)
   - ws.on('timeupdate', (time) => currentTime = time)
   - ws.on('ready', () => isLoading = false)
   - ws.on('error', (err) => { console.error('WaveSurfer error:', err); isLoading = false; })

5. Set wavesurfer = ws so the template can reference it.

6. Return cleanup function: `return () => { ws?.destroy(); }`

Template structure (in order, top to bottom):
```
<div class="waveform-player">
  <!-- Loading indicator (shown when isLoading is true) -->
  {#if isLoading}
    <div class="flex items-center justify-center h-20 text-zinc-500">
      <span>Loading waveform...</span>
    </div>
  {/if}

  <!-- Waveform container (always in DOM for wavesurfer binding, hidden while loading) -->
  <div bind:this={container} class:hidden={isLoading}></div>

  <!-- Controls bar: play/pause button, time display, volume slider -->
  <div class="flex items-center gap-4 mt-2">
    <!-- Play/Pause button -->
    <button
      onclick={() => wavesurfer?.playPause()}
      disabled={isLoading}
      class="..."
    >
      {isPlaying ? 'Pause' : 'Play'}
    </button>

    <!-- Time display: currentTime / duration -->
    <span class="text-sm text-zinc-400 font-mono tabular-nums">
      {formatTime(currentTime)} / {formatTime(duration)}
    </span>

    <!-- Spacer -->
    <div class="flex-1"></div>

    <!-- Volume control -->
    <div class="flex items-center gap-2">
      <span class="text-xs text-zinc-500">Vol</span>
      <input
        type="range"
        min="0"
        max="1"
        step="0.01"
        value={volume}
        oninput={(e) => {
          volume = parseFloat(e.currentTarget.value);
          wavesurfer?.setVolume(volume);
        }}
        class="w-20 accent-violet-500"
      />
    </div>
  </div>
</div>
```

Styling: Use Tailwind utility classes. The waveform colors are defined in the WaveSurfer.create options (#4a4a5a wave, #8b5cf6 progress/cursor -- violet tones matching the dark/moody aesthetic). Keep button and control styling minimal but functional -- Phase 4 will do the full visual design pass.

Import formatTime at the top of the script tag (static import is fine since it's a local utility, not a DOM library).
  </action>
  <verify>
1. `npm ls wavesurfer.js` shows wavesurfer.js installed
2. `svelte-check` passes with 0 errors
3. src/lib/utils/formatTime.ts exists and exports formatTime
4. src/lib/components/WaveformPlayer.svelte exists
5. Grep confirms: dynamic import of wavesurfer.js inside the component, $props() usage, $state() usage, onMount lifecycle, destroy cleanup
  </verify>
  <done>wavesurfer.js is installed, formatTime utility exists and handles edge cases, WaveformPlayer.svelte component handles play/pause (PLAY-01), drag-to-seek (PLAY-02), pre-generated peaks (PLAY-03), time display (PLAY-06), volume control (PLAY-07), and loading state (UI-03)</done>
</task>

<task type="auto">
  <name>Task 2: Wire WaveformPlayer into the main page and verify end-to-end</name>
  <files>
    src/routes/+page.server.ts
    src/routes/+page.svelte
  </files>
  <action>
**Step 1: Update +page.server.ts**

Modify the existing src/routes/+page.server.ts to query ready tracks from the database. The current page.server.ts likely just returns a track count. Update it to:

1. Import db from '$lib/server/db/client' and tracks from '$lib/server/db/schema'
2. Import eq from 'drizzle-orm'
3. Query all tracks with status='ready': `db.select().from(tracks).where(eq(tracks.status, 'ready')).all()`
4. Return the track list with at minimum: id, title, duration, slug, status

The load function should return: `{ tracks: readyTracks }`

**Step 2: Update +page.svelte**

Replace the existing landing page content to display ready tracks with WaveformPlayer components.

1. Import WaveformPlayer from '$lib/components/WaveformPlayer.svelte'
2. Receive page data via `let { data } = $props()`

Template:
```
<div class="max-w-3xl mx-auto p-6">
  <h1 class="text-3xl font-bold text-white mb-8">wallybrain</h1>

  {#if data.tracks.length === 0}
    <p class="text-zinc-500">No tracks yet.</p>
  {:else}
    <div class="space-y-8">
      {#each data.tracks as track (track.id)}
        <div class="bg-zinc-900 rounded-lg p-4">
          <h2 class="text-lg font-semibold text-zinc-200 mb-3">{track.title}</h2>
          <WaveformPlayer trackId={track.id} duration={track.duration ?? 0} />
        </div>
      {/each}
    </div>
  {/if}
</div>
```

Use dark background classes (bg-zinc-950 on body or layout is fine -- Phase 4 will refine). The key thing is functional: each ready track gets a WaveformPlayer instance.

**Step 3: Docker rebuild and verify**

Rebuild and restart the Docker container:
```bash
cd /home/lwb3/wallybrain-music && docker compose up -d --build
```

Wait for the container to be healthy, then verify:
1. Visit http://localhost:8800/music/ -- should show the page with track cards
2. If there are ready tracks, each should show a waveform visualization
3. Clicking Play should start audio playback and animate the waveform progress
4. Clicking/dragging on the waveform should seek
5. Time display should update in real time
6. Volume slider should adjust audio level

If no ready tracks exist from Phase 2 testing, upload a test track:
```bash
curl -X POST http://localhost:8800/music/api/upload -F "audio=@/path/to/test.mp3"
```
Then wait a few seconds for processing and reload the page.
  </action>
  <verify>
1. `svelte-check` passes with 0 errors
2. Docker container builds and starts healthy
3. `curl -s http://localhost:8800/music/ | grep -o 'wallybrain'` returns "wallybrain"
4. Page loads in browser with track listing (or "No tracks yet" if no ready tracks)
5. If ready tracks exist: waveform renders immediately from peaks, play/pause works, seeking works, time updates, volume adjusts
6. Browser console shows no errors (no SSR failures from wavesurfer.js, no 404s for API endpoints)
  </verify>
  <done>The main /music page displays all ready tracks with interactive WaveformPlayer components. Visitors can play/pause audio, see animated waveform progress, seek by clicking/dragging, see real-time time display, and adjust volume. Waveform renders instantly from pre-generated peaks.</done>
</task>

</tasks>

<verification>
Phase 3 end-to-end verification:
1. Visit wallyblanchard.com/music (or localhost:8800/music/) and see track listing
2. Click Play on a track -- waveform animates, audio plays from speakers
3. Click Pause -- audio stops, waveform freezes at current position
4. Click on a different position in the waveform -- audio seeks to that point and resumes
5. Drag across the waveform -- audio follows the drag position (PLAY-02 scrub)
6. Time display shows current position and total duration, updating in real time
7. Move volume slider -- audio volume changes
8. Waveform appeared instantly on page load (no decoding delay)
9. Loading indicator shown briefly while wavesurfer initializes, then disappears
10. curl -sI -H "Range: bytes=0-1" .../api/tracks/{id}/audio returns 206 (Safari compatibility)
</verification>

<success_criteria>
- PLAY-01: Play/pause works with waveform animation
- PLAY-02: Click and drag to seek works
- PLAY-03: Waveform renders from server-side peaks (no client-side decoding)
- PLAY-06: Time display updates in real time
- PLAY-07: Volume slider adjusts audio level
- INFRA-04: Audio streaming supports range requests (verified in 03-01)
- UI-03: Loading state shown while wavesurfer initializes
</success_criteria>

<output>
After completion, create `.planning/phases/03-waveform-player/03-02-SUMMARY.md`
</output>
